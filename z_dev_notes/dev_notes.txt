
nextjs upcoming release 
new api for tagging functions and specific tags 
for caching, so react knows what to check to re-render 

define data fetching pattern - server actions
form submission pattern 

creating new order form
new 'create' route in orders folder 
    'create' folder with page.tsx

    import Form from '@/app/ui/order/create-form';
import Breadcrumbs from '@/app/ui/order/breadcrumbs';
import { fetchCustomers } from '@/app/lib/data';
 
export default async function Page() {
  const customers = await fetchCustomers();
  //customers for dropdown menu 
  return (
    <main>
      <Breadcrumbs
        breadcrumbs={[
          { label: 'Orders', href: '/dashboard/orders' },
          {
            label: 'Create Order',
            href: '/dashboard/orders/create',
            active: true,
          },
        ]}
      />
      <Form customers={customers} />
    </main>
  );
}

<form> has: input, dropdown, input of type number and radio, cancel, and submit 

create a  actions.ts in app/lib 
   'use server';
    export async function createOrder(formData: FormData) {} 

import this function in form component and add the action attribute 
<form action={createOrder}> asdfa f </form>

Good to know: In HTML, you'd pass a URL to the action attribute. This URL would be the destination where your form data should be submitted (usually an API endpoint).

However, in React, the action attribute is considered a special prop - meaning React builds on top of it to allow actions to be invoked.

Behind the scenes, Server Actions create a POST API endpoint. This is why you don't need to create API endpoints manually when using Server Actions.


updating an order 
	create new dynamic route segment with the order id 
	read the order id from the page params 
	fetch the specific order from db 
	pre-populate the form with the order data 
	update the order data in db  


code organization 
app/
  ui/
  etc 

branching strategy and conventions 

environment configuration 
  dotenv 

code quality and style 
eslint and prettier configs

testing - Jest 

versioning dependencies 


adding a new fetch feature 
stub in page 
stub in component 
buttons in datatable and columnst tsx 
create a corresponding action 
create a corresponding object for receiving data from db query 
test 
add error handling 
add all required fields 

NextJS 
Server Actions are not limited to <form> and can be invoked from event handlers, useEffect, third-party libraries, and other form elements like <button> 

TypeScript
classes vs types for data modeling 

classes 
imperative code describes the steps that the runtime must take to inialize an object
declarative code describes the state of the initialized object

How we instantiated const user: User = { above 
is declarative; we're declaring the object in its full state. 
Imperative code, on the other hand, declares the object, then describes all of the steps to build it: 

immutable practices
You can't really even test test a unit. It might work in a unit test without the other parts, but if other parts modify it, then your test is useless. 
It becomes impossible to even identify all of the code paths. 
Conversely, code using immutable practices grows in complexity linearly. 
This piece always takes this value in and sends that value out. Tested, done, and on to the next part.

JSX 
wrap elements in Link, rather than putting Link in an element: this way, if you put a button in a link, the whole button is clickable 
  this was how I resolved the Edit Order button bug 