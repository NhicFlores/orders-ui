import { db } from "@/drizzle/db";
import { eq, sql } from "drizzle-orm";
import {
  CustomerTable,
  InventoryProductTable,
  OrderInvoiceTable,
  OrderItemTable,
  OrderTable,
  UserProfileTable,
} from "@/drizzle/schema";
import {
  InvoiceField,
  ItemTableRow,
  AllOrderFormFields,
  OrderPageFields,
} from "@/lib/data-model/query-types";
import { Customer, Order } from "@/lib/data-model/schema-types";
import {
  isValidOrderStatus,
  OrderStatusOptions,
} from "@/lib/data-model/enum-types";
import { BillingFields, ShippingFields } from "@/lib/data-model/utility-types";

/**
 * @description fetches all data required by order page from multiple tables
 * @param orderId unique order id generated by the database
 * @returns object with order details such as customer, shipping, billing, and order items
 */
export async function fetchAllOrderFormFieldsById(
  orderId: string
): Promise<AllOrderFormFields> {
  try {
    // console.log("---- ORDER ID ----");
    // console.log(orderId);
    // console.log("----");
    const result = await db
      .select({
        order_id: OrderTable.order_id, // programmatic
        created_by: OrderTable.created_by, // programmatic
        customer_id: OrderTable.customer_id, // programmatic
        order_name: OrderTable.order_name, //
        order_number: OrderTable.order_number, // modifiable conditionally
        shipping_data: OrderTable.shipping_data, // modifiable conditionally
        billing_data: OrderTable.billing_data, // modifiable conditionally
        status: OrderTable.status, // programmatic
        amount: OrderTable.amount, // modifiable conditionally
        date_drafted: OrderTable.date_drafted, // programmatic
        date_updated: OrderTable.date_updated, // programmatic
        date_submitted: OrderTable.date_submitted, // programmatic
        date_shipped: OrderTable.date_shipped, // modifiable conditionally
        date_delivered: OrderTable.date_delivered, // modifiable conditionally
        order_invoice_id: OrderInvoiceTable.order_invoice_id,
        invoice_number: OrderInvoiceTable.invoice_number,
        ordered_by:
          sql<string>`${UserProfileTable.first_name} || ' ' || ${UserProfileTable.last_name}`.as(
            "ordered_by"
          ),
        // order_items: OrderItemTable,
        customer_name: CustomerTable.name,
      })
      .from(OrderTable)
      .where(eq(OrderTable.order_id, orderId))
      .leftJoin(
        UserProfileTable,
        eq(OrderTable.created_by, UserProfileTable.user_id)
      )
      .leftJoin(
        OrderInvoiceTable,
        eq(OrderTable.order_id, OrderInvoiceTable.order_id)
      )
      .leftJoin(
        CustomerTable,
        eq(OrderTable.customer_id, CustomerTable.customer_id)
      );
    // .leftJoin(
    //   OrderItemTable,
    //   eq(OrderTable.order_id, OrderItemTable.order_id)
    // );

    // console.log("---- fetchOrderDetailsById ----");
    // console.log("RESULT");
    // console.log(result);
    // console.log("RESULT LENGTH");
    // console.log(result.length);
    // const reducedResult = result.reduce<OrderDetails>((acc, row) => {

    // }, {});
    // TODO NOTE: destructure the result and process each field to strongly type the result

    // console.log(" ELEMENT 0 ");
    // console.log(result[0]);
    // console.log("----");
    // console.log(" ELEMENT 1 ");
    // console.log(result[1]);
    // console.log("----");

    const orderInfo = {
      ...result[0],
      status: isValidOrderStatus(result[0].status)
        ? result[0].status
        : OrderStatusOptions.Draft,
      amount: parseFloat(result[0].amount),
      shipping_data: result[0].shipping_data as ShippingFields,
      billing_data: result[0].billing_data as BillingFields,
      date_drafted: new Date(result[0].date_drafted),
      date_updated: new Date(result[0].date_updated),
      date_submitted: result[0].date_submitted
        ? new Date(result[0].date_submitted)
        : null,
      date_shipped: result[0].date_shipped
        ? new Date(result[0].date_shipped)
        : null,
      // order_items: [],
      order_invoice_id:
        result[0].order_invoice_id ?? "THIS ORDER DOES NOT HAVE AN INVOICE",
      // ordered_by: result[0].ordered_by,
      customer_name: result[0].customer_name ?? "Customer not found",
    };

    return orderInfo;
  } catch (error) {
    throw new Error("Database Error: Failed to fetch order details");
  }
}

/**
 * @description fetches order page data from order, customer, and profile table
 * @param orderId unique order id generated by the database
 * @returns orderPageFields object with order details such as customer, shipping, billing, and order items
 */
export async function fetchOrderFormFieldsById(
  orderId: string
): Promise<OrderPageFields> {
  try {
    const result = await db
      .select({
        // order table
        order_id: OrderTable.order_id,
        created_by: OrderTable.created_by,
        customer_id: OrderTable.customer_id,
        order_name: OrderTable.order_name,
        order_number: OrderTable.order_number,
        shipping_data: OrderTable.shipping_data,
        billing_data: OrderTable.billing_data,
        status: OrderTable.status,
        amount: OrderTable.amount,
        date_drafted: OrderTable.date_drafted,
        date_updated: OrderTable.date_updated,
        date_submitted: OrderTable.date_submitted,
        date_shipped: OrderTable.date_shipped,
        date_delivered: OrderTable.date_delivered,
        // profile table
        ordered_by:
          sql<string>`${UserProfileTable.first_name} || ' ' || ${UserProfileTable.last_name}`.as(
            "ordered_by"
          ),
        // customer table
        customer_name: CustomerTable.name,
      })
      .from(OrderTable)
      .where(eq(OrderTable.order_id, orderId))
      .leftJoin(
        UserProfileTable,
        eq(OrderTable.created_by, UserProfileTable.user_id)
      )
      .leftJoin(
        CustomerTable,
        eq(OrderTable.customer_id, CustomerTable.customer_id)
      );

    const order: OrderPageFields = {
      ...result[0],
      shipping_data: result[0].shipping_data as ShippingFields,
      billing_data: result[0].billing_data as BillingFields,
      status: isValidOrderStatus(result[0].status)
        ? result[0].status
        : OrderStatusOptions.Draft,
      amount: parseFloat(result[0].amount),
      date_drafted: new Date(result[0].date_drafted),
      date_updated: new Date(result[0].date_updated),
      date_submitted: result[0].date_submitted
        ? new Date(result[0].date_submitted)
        : null,
      date_shipped: result[0].date_shipped
        ? new Date(result[0].date_shipped)
        : null,
      date_delivered: result[0].date_delivered
        ? new Date(result[0].date_delivered)
        : null,
      customer_name: result[0].customer_name
        ? result[0].customer_name
        : "Customer not found",
    };

    return order;
  } catch {
    throw new Error("Database Error: Failed to fetch order");
  }
}

/**
 * @description fetches order invoice number from order invoice table
 * @param orderId unique order id generated by the database
 * @returns InvoiceField object with the invoice id and invoice number
 */
export async function fetchOrderInvoiceField(
  orderId: string
): Promise<InvoiceField> {
  try {
    const result = await db
      .select({
        invoice_id: OrderInvoiceTable.order_invoice_id,
        invoice_number: OrderInvoiceTable.invoice_number,
      })
      .from(OrderInvoiceTable)
      .where(eq(OrderInvoiceTable.order_id, orderId));

    return result[0];
  } catch {
    throw new Error("Database Error: Failed to fetch order invoice number");
  }
}

/**
 * @description fetches order items from order item table and joins with inventory product table to get product type and name
 * @param orderId unique order id generated by the database
 * @returns array of order items with product type and name
 */
export async function fetchOrderItems(
  orderId: string
): Promise<ItemTableRow[]> {
  try {
    const result = await db
      .select({
        order_item_id: OrderItemTable.order_item_id,
        order_id: OrderItemTable.order_id,
        product_type_id: OrderItemTable.product_type_id,
        product_config: OrderItemTable.product_config,
        quantity: OrderItemTable.quantity,
        note: OrderItemTable.note,
        type: InventoryProductTable.type,
      })
      .from(OrderItemTable)
      .where(eq(OrderItemTable.order_id, orderId))
      .leftJoin(
        InventoryProductTable,
        eq(OrderItemTable.product_type_id, InventoryProductTable.product_id)
      );

    // console.log(result);
    // console.log("ORDER ITEMS LENGTH");
    // console.log(result.length);

    return result as ItemTableRow[];
  } catch {
    throw new Error("Database Error: Failed to fetch order items");
  }
}
/**
 * @description fetches all customers from the database, will need to be paginated in the future
 * @returns array of Customer objects
 */
export async function fetchCustomers(): Promise<Customer[]> {
  try {
    const result = await db.select().from(CustomerTable);

    const customers = result.map((row): Customer => {
      return {
        ...row,
        email: row.email ? row.email : "No email",
        account_num: row.account_num ? row.account_num : "No account number",
        credit_status: row.credit_status
          ? row.credit_status
          : "No credit status",
        credit_limit: row.credit_limit ? parseFloat(row.credit_limit) : 0,
      };
    });

    return customers;
  } catch {
    throw new Error("Database Error: Failed to fetch customers");
  }
}

// the following type and function are for testing purposes
type OrderCustomer = Order & Customer;

export async function fetchOrderCustomerObject(
  order_id: string,
  customer_id: string
): Promise<OrderCustomer> {
  try {
    const orderCustomerResult = await db
      .select()
      .from(OrderTable)
      .where(eq(OrderTable.order_id, order_id))
      .leftJoin(
        CustomerTable,
        eq(OrderTable.customer_id, CustomerTable.customer_id)
      );

    const orderResult = await db
      .select()
      .from(OrderTable)
      .where(eq(OrderTable.order_id, order_id));

    const customerResult = await db
      .select()
      .from(CustomerTable)
      .where(eq(CustomerTable.customer_id, customer_id));

    const customer: Customer = {
      ...customerResult[0],
      credit_limit: customerResult[0].credit_limit
        ? parseFloat(customerResult[0].credit_limit)
        : 0,
    };

    const order: Order = {
      ...orderResult[0],
      status: isValidOrderStatus(orderResult[0].status)
        ? orderResult[0].status
        : OrderStatusOptions.Draft,
      amount: parseFloat(orderResult[0].amount),
    };

    console.log(" ");
    console.log("---- ORDER OBJECT ----");
    console.log(" ");
    console.log(orderResult);
    console.log(" ");
    console.log("--- CUSTOMER QUERY RESULT ---");
    console.log(" ");
    console.log(customerResult);
    console.log(" ");
    console.log("--- CUSTOMER OBJECT ---");
    console.log(customer);
    console.log(" ");
    console.log("---- ORDER CUSTOMER OBJECT ----");
    console.log(" ");
    console.log(orderCustomerResult);

    // const orderCustomer: OrderCustomer = {
    //   ...orderCustomerResult[0],
    //   customer: {
    //     ...orderCustomerResult[0].customer,
    //     account_num: orderCustomerResult[0].customer?.account_num
    //       ? orderCustomerResult[0].customer.account_num
    //       : "No account number",
    //     credit_status:
    //       orderCustomerResult[0].customer?.credit_status ?? "No credit status",
    //     credit_limit: orderCustomerResult[0].customer?.credit_limit
    //       ? parseFloat(orderCustomerResult[0].customer.credit_limit)
    //       : 0,
    //   },
    //   order: {
    //     ...orderCustomerResult[0].order,
    //     status: orderCustomerResult[0].order.status as OrderStatus,
    //     amount: parseFloat(orderCustomerResult[0].order.amount),
    //     shipping_data: orderCustomerResult[0].order
    //       .shipping_data as OrderShippingInfo,
    //     billing_data: orderCustomerResult[0].order
    //       .billing_data as CustomerBillingInformation,
    //     date_submitted: orderCustomerResult[0].order.date_submitted
    //   },
    // };

    const orderCustomer: OrderCustomer = {
      ...order,
      ...customer,
      // ...orderCustomerResult[0].order,
      // status: orderCustomerResult[0].order.status as OrderStatus,
      // ...orderCustomerResult[0].customer,
    };
    console.log(" ");
    console.log("---- ORDER CUSTOMER OBJECT ----");
    console.log(orderCustomer);

    return orderCustomer;
  } catch (error) {
    throw new Error("Database Error: Failed to fetch order object");
  }
}
